# 프로젝트 진행 중 메모

### ● 게시판 구현시 고려사항

##### 1. 게시판 종류에 따른 모델 설계 방식 선정 (종류별로 모델만들기 선정)

- **종류별로 모델 만들기 vs 한 모델에 종류를 구분하는 필드 추가하기**

  - **각 종류별로 게시판 모델 생성**

    - 장점
      - **명확한 구조:** 각 모델이 독립적, 구조적으로 명확함.
      - **좋은 확장성:** 개별 게시판에 맞는 기능 추가 용이.
      - **쉬운 유지보수:** 모델별 독립적 변경 가능.

    - 단점

      - **중복 코드:** 유사 기능/필드의 반복.

      - **관리 복잡성:** 여러 모델 관리 필요

  - **하나의 게시판 모델에 종류 구분 필드 사용**

    - 장점

      - **중복 감소:** 공통 기능/필드 중복 최소화.

      - **통합 관리 용이:** 한 모델로 모든 게시글 관리.

    - 단점

      - **복잡한 모델 구조:** 다양한 기능/필드로 인해 복잡.

      - **유연성 감소:** 특정 변경이 전체 모델에 영향.

      - **가능한 성능 문제:** 특정 데이터 필요 시 전체 조회 필요할 수 있음.

- **요약**
- **게시글 차이가 적고 공통 속성이 많다면:** 하나의 모델 사용
  
- **게시글 종류마다 독특한 속성이나 동작이 있다면:** 별도 모델 생성

##### 2. 댓글 모델 하나로 여러 종류의 게시판 연결 시키는 방법

- 댓글의 경우 특정 게시판에 달린 댓글 별로 독립적인 기능을 할 필요가 없다고 판단되기 때문에 댓글 모델 하나로 구성함

  - 각 게시판 모델에 대한 별도의 외래키를 설정하는 방법
    - **`null=True`**: 해당 필드가 `NULL` 값을 가질 수 있음을 의미. 즉, 데이터베이스에 해당 필드가 비어 있을 수 있음.
    - **`blank=True`**: 폼 유효성 검사에서 해당 필드가 비어 있을 수 있음을 의미. 즉, Django의 폼 시스템에서 사용자가 이 필드를 비워 두고 제출해도 유효한 입력으로 간주함.
  
  ```python
  #models.py 에 comment 모델 field에 작성
  finance_review = models.ForeignKey(FinanceReview, on_delete=models.CASCADE, null=True, blank=True)
  product_review = models.ForeignKey(ProductReview, on_delete=models.CASCADE, null=True, blank=True)
  
  #serializer.py
  from rest_framework import serializers
  from .models import Comment
  
  class CommentSerializer(serializers.ModelSerializer):
      class Meta:
          model = Comment
          fields = '__all__'
  
      def to_representation(self, instance):
          representation = super().to_representation(instance)
          # 외래키 필드가 비어있는 경우, 해당 필드를 Response에서 제외하는 로직
          if not instance.finance_review:
              representation.pop('finance_review', None)
          if not instance.product_review:
              representation.pop('product_review', None)
          return representation
  ```
  
  
  
  